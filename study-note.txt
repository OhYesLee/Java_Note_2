흐름

    개발자 업무 영역 (코드 작성) -> 컴파일러 (기계어로 변환) -> 컴퓨터

Java 언어의 탄생

    - 1995년 제임스 고슬링에 의해 탄생
    - 가전제품에 탑재할 수 있는 프로그램을 개발하기 위해 탄생 (실제로는 성공 많이 못 얻음)
    - 인터넷 활성화 이후 JSP Servlet 유행

Java 언어의 장점

    - 객체 지향 언어로 기능을 부품화 할 수 있다.
    - JRE를 이용해서 운영체제로부터 자유롭다. (윈도우, 리눅스, 맥OS 다 돌아감)
    - 웹 및 모바일 (안드로이드, IOS에서 안드로이드는 자바 기반) 프로그래밍이 쉽다.
    - GC를 통한 자동 메모리 관리를 지원한다. 
      (메모리를 쓰고 반환하는 액션을 취하지 않아도 된다. 알아서 정리해주기 때문)
    - 실행 속도가 많이 개선되어 빨라졌다.

    * 제일 큰 장점은 객체 지향 언어로 기능을 부품화 할 수 있다는 것.

Java와 C의 차이점

    - C랑 C++ 은 메모리를 직접 관리한다. 메모리에 직접 접근하여 제어한다.
    - JAVA 언어는 메모리를 개발자가 직접 관리할 수 없다. 
      (초기에는 속도가 C와 C++에 비해 느리고 무거웠다. 현재는 많이 빨라짐)

JDK

    Java Development Kit - 개발자는 JDK가 있어야 개발을 할 수 있다.
    단지 프로그램만을 사용하는 사용자라면 JRE만 설치되어 있으면 된다.

    JDK 안에 JRE 안에 API 안에 JVM

    JRE는 OS마다 다 준비되어 있으므로 OS의 간섭을 받지 않고
    JDK로 한번 개발을 하면 원하는 운영 체제에서 두루두루 사용이 가능하다.

* API 는 간단하게 기능이라고 생각하자.

Java 컴파일러와 JVM

    java 소스 (xxx.java)     ->     바이트 코드 파일 (xxx.class)        ->          기계어        ->         실행
                          java 컴파일러                              JVM구동     (메모리 로딩 / 실행 준비 / 실행 결정 / 초기화 )
                            (javac.exe)                            (java.exe)                   LINK


가비지 컬렉터 (Garbage Collector)

    - 프로그램 실행에 필요한 메모리를 가비지 컬렉터가 자동으로 관리한다.

    C계열 프로그램 << 개발자가 직접 메모리를 관리해야 한다. 메모리 관리를 잘못할 경우 메모리 누수가 발생하고
                     타 프로그램 동작이 멈출 수 있음. 메모리 관계를 맺었다가 끊어줬다가를 직접 해야함
    
    Java 프로그램 << 개발자가 메모리에 접근할 수 없다. 따라서 개발자는 메모리 관리를 할 수 없고,
                     가비지 컬렉터가 불필요한 메모리를 회수하여 메모리를 최적화한다.


자바의 흐름 원리

    * 코드를 짜고 javac.exe 컴파일러로 컴파일을 해야하고, java 파일이 class로 변환(생성)되면 java.exe(JVM) 를 이용해서 실행을 시켜준다.

--------------------------------------------------

변수란?

    데이터(자료)를 임시로 담을 수 있는 상자(메모리 공간)

    선언부 작업 - 메모리 공간을 확보
    대입연산자를 이용해서 확보한 메모리 공간에 값을 초기화시킨다.


변수 선언과 초기화

    * 선언은 한번만 가능

    변수 선언 후 초기화 진행

        int i; // 변수 선언
        i = 10; // 변수 초기화
        System.out.println("i = " + i);

    변수 선언과 초기화를 동시에 진행

        int j = 20; // 변수 선언&초기화
        System.out.println("j = " + j);

메모리 할당과 진법

    * 8bit는 1byte
    
    int 자료형은 메모리에서 4byte 공간을 차지한다. ( 32 bit, 즉 32개의 공간이 생김 )
    값은 이진수(binary)로 변환되어 공간에 들어간다.

변수 데이터 변경

    변수에 저장된 데이터는 언제든지 변경할 수 있다.

변수를 쓰는 이유?

    - 값을 재활용 하기 위해서

-----------------------------------------------------

기본 자료형과 객체 자료형

    기본 자료형 (Primitive Type 원시 타입)

        * 실수, 정수, boolean, 문자, 문자열

        데이터가 변수에 직접 저장된다. (데이터가 메모리에 직접 들어간다.)

    객체 자료형 (Reference Type 참조 타입)

        객체 메모리 주소가 변수에 저장된다. (C계열에서는 포인터라고 하고, Java에서는 레퍼런스라고 한다.)
        
        객체를 가르키는 주소를 메모리에 담는다. (참조)

        항상 16진수의 주소만 들어간다.

Java의 기본 자료형

    정수형

        - byte 1byte ( -128 ~ +127, 256개. 숫자 넘으면 overflow 발생 8bit, -2의 7승 ~ 2의 7승 - 1)
        - char 2byte ( A, b 처럼 단일 문자. 많이 쓰이진 않음. 근데 왜 정수? 아스키 코드 때문!(숫자로 대체됨) )
        - short 2byte ( -32768 ~ 32768 바이트보단 크지만 자주 쓰이진 않는다. 보다 큰수 표현 가능 )
          2yte이므로 16bit, -2의 15승 ~ 2의 15승-1

        - int 4byte ( 작은 숫자부터 중간 숫자, 가장 많이 쓰임 -2의 31승 ~ 2의 31승 - 1 약 20억개, 32비트)
        - long 8byte ( 64bit, -2의 63승 ~2의 63승 - 1)

    실수형

        - float 4byte
        - double 8byte (많이 쓰임 거의 모든 소수점을 다 쓸 수 있음. 64bit)

    논리형 - boolean 1byte 참과 거짓 (8bit 크기 차지)

    * 문자열은?? String 은 문자열은 다룬다. (기본 자료형이 아닌 객체 자료형이다. 4byte)

형 변환

    // 자동 (묵시적) 형 변환
    // 작은 공간의 메모리에서 큰 메모리로 이동
    byte by = 10;
    int in = by;
    System.out.println("in = " + in);

    // 명시적 형 변환: 괄호로 명시해주어야 한다!
    // 큰 공간의 메모리에서 작은 공간의 메모리로 이동
    int iVar = 100;
    byte bVar = (byte)iVar;
    System.out.println("bVar = " + bVar);

    iVar = 123456;
    bVar = (byte)iVar;
    System.out.println("bVar = " + bVar);


    * 명시적 형 변환은 데이터가 누실, 훼손될 수 있다.

------------------------------------------------------

JSP - HTML을 기반으로 한 jsp 코드를 넣어서 만든 서버사이드 파일 

     작업파일 -> 컴파일하여 클래스로 만들어줌 -> 실행

Servlet - java 만을 기반으로 만든 서버사이드 파일

    컴파일하여 클래스로 만들고 실행

------------------------------------------------------

특수 문자와 서식 문자

    특수 문자 - 일반 문자가 아닌 특수한 목적으로 사용되는 문자

        \t 탭
        \n 줄 바꿈
        \' 작은 따옴표
        \" 큰 따옴표
        \\ 역슬래쉬

    서식 문자 - 일반 문자가 아닌 서식에 사용되는 문자

        printf() 메서드 이용
        :f는 format(형식)을 뜻함.

        %d 10진수
        %o 8진수
        %x 16진수
        %c 문자
        %s 문자열
        %f 실수
    
    * println 은 문자를 출력해주고 개행을 자동으로 해준다.
    * printf 는 개행을 수동으로 해야 한다. 서식문자를 사용한다.

    ex) System.out.println("오늘의 기온은 10도 입니다.");
        System.out.printf("오늘의 기온은 %d도 입니다.\n", 10);

        int num1 = 20;
        System.out.println("오늘의 기온은 "+ num1 +"도 입니다.");
        System.out.printf("오늘의 기온은 %d도 입니다.\n", num1);

        System.out.printf(" %d학년 %d반 %d번\n", 6, 2, 10);

    서식 문자 정렬 기능

        - 기본

            System.out.printf("%d\n", 123);
            System.out.printf("%d\n", 1234);
            System.out.printf("%d\n", 12345);

            123
            1234
            12345

        - 오른쪽 정렬을 할 때에는 %5d 를 이용하면 된다.

            System.out.printf("%5d\n", 123);
            System.out.printf("%5d\n", 1234);
            System.out.printf("%5d\n", 12345);

              123
             1234
            12345

    서식 문자 소수점 제한 기능

        System.out.printf("%f\n", 1.23);
        System.out.printf("%.0f\n", 1.23);
        System.out.printf("%.1f\n", 1.23);
        System.out.printf("%.2f\n", 1.23);
        System.out.printf("%.3f\n", 1.23);

        1.230000
        1
        1.2
        1.23
        1.230

-----------------------------------------

연산자

- 단항 연산자

    피연산자가 하나 존재

    +x, -x, !x

- 이항 연산자

    피연산자가 두개 존재

    x = y, x < y, x!=y

- 삼항 연산자

    피연산자가 세개 존재

    조건식 : true ? false

대입 연산자

    '='는 수학에서 '오른쪽 값과 왼쪽 값이 같다' 라는 의미 이지만,
    프로그램에서는 '오른쪽 값을 왼쪽에 대입' 하는 의미로 쓰인다.

        프로그램에서 '오른쪽과 왼쪽이 같다' 의미는 '==' 이다.

산술 연산자

    피연산자를 이용해서 +, -, *, /, % 등을 수행한다.

    + 덧셈
    - 뺄셈
    * 곱셈
    / 나눗셈
    % 나머지

복합 대입연산자

    += 더하고 대입
    -= 빼고 대입
    *= 곱하고 대입
    /= 나누고 대입
    %= 나머지를 대입

    예제

        x = 10;
        System.out.println("x += 10 : " + (x += 10));
        x = 10;
        System.out.println("x -= 10 : " + (x -= 10));
        x = 10;
        System.out.println("x *= 10 : " + (x *= 10));
        x = 10;
        System.out.println("x /= 10 : " + (x /= 10));
        x = 10;
        System.out.println("x %= 10 : " + (x %= 10));

    예제 결과
    
        x += 10 : 20
        x -= 10 : 0
        x *= 10 : 100
        x /= 10 : 1
        x %= 10 : 0

관계 연산자

    >, <, >=, <=, ==, !=

증감 연산자

    ++ 1만큼 증가
    -- 1만큼 감소

    * 앞에 두면 전위연산자, 일단 메모리 상에 값을 더한 다음 출력한다.
      뒤에 두면 일단 출력한 다음에 메모리 상에 값을 더한다.

논리 연산자

    피연산자의 논리곱(AND), 논리합(OR), 논리부정(NOT)을 수행한다.

    && 논리곱(AND) - a&&b : a와 b가 모두 참이면 참
    || 논리합(OR) - a||b : a와 b중 하나라도 참이면 참
    ! 논리부정(NOT) - ! a:a의 상태를 부정

조건 (삼항) 연산자

    조건식 ? 식1 : 식2

    조건식이 참이면 식1이 실행되고,
    조건식이 거짓이면 식2가 실행된다.

비트 연산자

    데이터를 비트(bit)단위로 환산하여 연산을 수행하며, 다른 연산자보다 연산 속도가 향상된다.

    많이 쓰이진 않는다. 연산 방법 정도만 알아두자.

    * 이진법 사용

    & : AND 연산 - a & b : a와 b가 모두 1이면 1
    | : OR 연산 - a | b : a와 b중 하나라도 1이면 1
    ^ : XOR 연산 - a^b : a와 b가 같지 않으면 1

-------------------------------------------------

배열

    인덱스를 이용해서 자료형이 같은 데이터를 관리하는 것이다.

    배열도 변수와 마찬가지로 선언과 초기화 과정을 거쳐 사용한다.

        

        - 배열 선언 후 초기화

            int[] arr1 = new int[5]; // 배열 선언 단계
            arr1[0] = 100;
            arr1[1] = 200;
            arr1[2] = 200;
            arr1[3] = 200;
            arr1[4] = 200;

            System.out.println("arr[0] : " + arr[0]);
            System.out.println("arr[1] : " + arr[1]);
            System.out.println("arr[2] : " + arr[2]);

        - 배열 선언과 초기화를 동시에

            /*
            int [] arr2 = new int[3];
            arr2[0] = 10;
            arr2[1] = 20;
            arr2[2] = 30;
            */

    * 존재하지 않는 범위의 인덱스를 사용하면 에러가 난다.

    * 자바는 한번 배열을 선언하면 그 크기가 변경되지 않는다! 
      자바 언어의 특징! 다른 언어는 동적으로 변경가능.

    배열은 주로 많은 데이터를 쉽게(효율적) 관리하기 위해서 사용한다.

배열을 이용한 학사관리

    String[] name = {"박찬호", "이승엽", "박병호", "이병규", "류현진"};
    int[] score = new int[5];
    Scanner scanner = new Scanner(System.in); // 사용자로부터 데이터를 받을 때 사용하는 클래스이다. (데이터를 waiting 하고 있는 객체)
    System.out.printf("%s의 점수를 입력하시오 : ", name[0]);
    score[0] = scanner.nextInt(); // 사용자로부터 입력 값을 받는다.

    System.out.printf("%s의 점수를 입력하시오 : ", name[1]);
    score[1] = scanner.nextInt(); // 사용자로부터 입력 값을 받는다.

    System.out.printf("%s의 점수를 입력하시오 : ", name[0]);
    score[2] = scanner.nextInt(); // 사용자로부터 입력 값을 받는다.

    System.out.printf("%s의 점수를 입력하시오 : ", name[0]);
    score[3] = scanner.nextInt(); // 사용자로부터 입력 값을 받는다.

    System.out.printf("%s의 점수를 입력하시오 : ", name[0]);
    score[4] = scanner.nextInt(); // 사용자로부터 입력 값을 받는다.

    System.out.printf("%s 점수 : \t%.2f\n", name[0], (double)score[0]);
    System.out.printf("%s 점수 : \t%.2f\n", name[0], (double)score[1]);
    System.out.printf("%s 점수 : \t%.2f\n", name[0], (double)score[2]);
    System.out.printf("%s 점수 : \t%.2f\n", name[0], (double)score[3]);
    System.out.printf("%s 점수 : \t%.2f\n", name[0], (double)score[4]);

    double average = (double)(score[0] + score[1] + score[2] + score[3] + score[4]) / 5;
    System.out.printf("--------------\n평 점 : \t%.2f", average);

    scanner.close(); // 클래스를 사용했으면 리소스를 반환해줘야 한다.

--------------------------------------------------------

배열과 메모리

    배열의 메모리 크기

        배열을 구성하는 데이터의 자료형에 따라서 배열의 메모리 크기가 결정된다.

        int [] arr = new int[3];

    <- int형 : 4byte -><- int형 : 4byte ->< int형 : 4byte ->
    <-                  arr : 12byte                      ->

    배열 기본 속성

        기본 자료형 데이터를 담고 있는 변수와 달리 배열 변수는 배열 데이터의 주소를 담고 있다.

        * 값이 같다고 같은 객체라고 생각하면 안된다. 주소가 다를 수 있다.

        ex) int[] arrAtt1 = {10, 20, 30, 40, 50, 60};

    다차원 배열

        배열안에 또다른 배열이 존재한다.

        int[][] arrMul = new int[3][2]; // 3행 x 2열의 공간.

        * 3차원 이후부터는 사용하기도 어렵고 메모리도 급격하게 늘어나므로 사용하지 않는다.

    * 배열 요소를 복사하여 새로운 객체를 만드는 것과 배열 레퍼런스, 즉 주소를 복사하는 것은 엄연히 다르다!
      이것을 구분할 줄 알아야 한다!

        요소 복사 예제 : 
            
            arrAtt3 = Arrays.copyOf(arrAtt1, arrAtt1.length);
            System.out.println("arrAtt3 : " + Arrays.toString(arrAtt3));

        배열 래퍼런스

            int[] arrAtt1 = {10, 20, 30, 40, 50, 60};

            arrAtt2 = arrAtt1;

---------------------------------------

조건문

    switch 문

        비교대상이 되는 결과 값과 선택사항이 많을 경우 주로 사용

반복문

    프로그램 진행을 특정 조건에 따라 반복적으로 하는 것이다.

    for 문

        ex)

        System.out.print("INPUT NUMBER : ");
        Scanner scanner = new Scanner(System.in);
        int inputNum = scanner.nextInt();

            for (int i = 0; i < 10; i++) {
                System.out.printf("%d * %d = %d\n", inputNum, i, (inputNum * i));
            }
    
    while 문

        바깥쪽에 변수, 증감식을 정의하고 사용한다.

    do while 문

        while 문과 비슷하며, 차이점은 조건 결과에 상관없이 무조건 최초한번은 { }의 프로그램을 수행한다.
        그 후 조건을 비교한다.

        즉 무조건 최소 1번은 실행하고 반복한다.

        ex ) 

            do {
                System.out.println("무조건 1번은 실행합니다.");
            } while (false);

---------------------------------------------------------------------------------

객체 지향 프로그래밍 (OOP)

    객체란?

        세상에 존재하는 모든 것을 뜻하며, 프로그래밍에서 속성과 기능을 가지는 프로그램 단위이다.

        ex) 객체(인간세계) 

            사람 - 속성 : 키, 몸무게 / 기능 : 의사
            TV - 속성 : 채널, 사운드 / 기능 : 미디어 방출
            자전거 - 속성 : 바퀴, 체인 / 기능 : 이동 수단
            체중계 - 속성 : 바늘, 눈금 / 기능 : 몸무게 측정

            객체(프로그램)

            날씨 프로그램 - 속성 : 온도, 미세먼지 / 기능 : 날씨예보
            사칙연산 프로그램 - 속성 : +, -, *, / / 기능 : 연산기능
        
        클래스란?

            객체를 생성하기 위한 틀로, 모든 객체는 클래스로부터 생성된다.
            심플, 간단하게 말하면 틀이다.

        * 쓰고있는 객체는 건들면 안됨! 연결되있지 않는 객체는 GC가 회수한다.

        클래스 구성요소?

            클래스는 속성(멤버 변수)와 기능(메서드)로 구성된다.

            ex) 자전거라는 객체의 속성(멤버 변수)는 안장, 핸들, 바구니, 기어, 페달, 바퀴
                 기능(메서드) 는 기어 변속, 가속, 브레이크 등등

        장점 : 프로그래밍을 다 할 필요가 없고, 이미 만들어져 있는, 또는 만든 프로그램을
                  기능과 속성들을 가지고 와서 조합하여 사용할 수 있다!!
                  언어의 확장성이 굉장히 좋아진다!

클래스 제작과 객체 생성

    클래스 제작

        예제 코드)

            package lec11Pjt001;

            public class Grandeur { // 클래스 이름 : 일반적으로 첫글자는 대문자

                public String color; // 멤버 변수(속성)
                public String gear;
                public int price;

                public Grandeur() { // 생성자 (자바에서의 생성자는 클래스와 이름이 같아야 한다.)
                    System.out.println("Grandeur constructor");
                }

                public void run() { // 메서드(기능)
                    System.out.println("-- run --");
                }

                public void stop() { // 메서드(기능)
                    System.out.println("-- stop --");
                }

            }

    객체 생성

        클래스로 부터 'new'를 이용해서 객체를 생성 한다.

    생성자

        클래스에서 객체를 생성할 때 가장 먼저 호출된다.
        생성자를 여러개 가질 수도 있다. (자바에서는 가능하다.)
        
        * PHP 클래스에는 고유 한 인수 시그니처가있는 두 개의 __construct 함수를 넣을 수 없다!!

------------------------------------------------------

메서드
    
    메서드 선언과 호출

        메서드도 변수와 같이 선언 및 정의 후 필요시에 호출해서 사용한다.

        메서드 이름은 동사를 앞에 두고 명사에 해당하는 목적어를 뒤에 두는 것이 일반적이다.
        (의미 파악에 수월. 일반적인 관례이다.)

        메서드를 호출할 때는 객체 접근자인 . 을 사용한다.

    매개변수

        메서드를 호출할 때 데이터를 전달할 수 있다.

        * 파라미터를 넣어줄 떄에는 자료형이 중요하다!! 매개변수인 데이터를 전달할 때는 자료형을 표기할 것.

    중복 메서드(overloading)

        이름은 같고, 매개변수의 개수 또는 타입이 다른 메서드를 만들 수 있다.

        파라미터의 차이가 있어야 중복하여 사용이 가능하다.

        * 파라미터의 갯수와 자료형에 차이를 두어 메서드를 중복하여 사용.

    접근자

        메서드를 호출할 때 접근자에 따라서 호출이 불가할 수 있다.

        메서드 호출부에서 private인 메서드에는 접근 불가능.
        외부에서는 public인 메서드에는 접근 가능.

        객체 자기자신 내에서는 private, public이던 상관없이 전부 접근 가능하다.

        private - 내부에서는 자유롭게 사용 가능
        public - 외부에서도 접근 가능

        접근자의 종류를 살펴보면 모든 메서드가 외부에서 접근 가능한 것은 아님을 알 수 있다.

---------------------------------------------

객체와 메모리

    메모리에서 객체 생성(동적 생성)

        class 를 이용하여 new 생성자로 새로운 객체를 생성했다고 가정해보자.

        새로운 객체는 메모리에서 동적으로 생성되며, 객체가 더 이상 필요 없게 되면 GC(Garbage Collector)에 의해서 제거된다.

        메모리에 생성된 객체가 어떠한 레퍼런스도 가지고 있지 않게되면, 즉 임자없는 객체가 되면 GC가 그것을 판단하여 회수한다.
        그 객체를 메모리에서 지워버림으로서 메모리를 넉넉하게 만들어준다.

    레퍼런스(가리킨다. 참조)

        생성한 객체의 주소를 변수에 저장하는 것을 레퍼런스라고 한다.

        * 똑같은 클래스를 가지고 객체를 여러개 찍어냈다면??
        
            동일한 메모리 공간에 생성된 것이 아닌 별도의 메모리 공간에 생성된 것이다.
            즉 동일한 객체가 아닌 엄연히 다른 공간에 존재하는 객체이다.

    자료형이 같아도 다른 객체

        자료형이 같아도 다른 공간에 존재하는 객체는 다른 객체이다.

        * 클래스가 같아도 다 다른 공간에 존재할 수 있다.

    null 과 NullPointException

        레퍼런스에 null 저장되면 객체의 연결이 끊기며, 더 이상 객체를 이용할 수 없다.
        
        주소와 객체와의 관계를 NULL을 저장함으로서 끊어버릴 수 있음.
        이렇게 되면 레퍼런스가 끊긴 객체는 언젠가 GC에 의해서 메모리에서 회수가 된다.

        레퍼런스 주소가 빈 곳(NULL)을 가리키고 있으면 NullPointException이 발생.

* 클래스로부터 생성되는 객체는 모두 다른 공간에 존재한다. 그 객체를 가리키는 주소를 레퍼런스라고 한다. 그 주소 관계를 끊어버리면 레퍼런스가 가리키고 있지 않은 객체는
  GC에 의해 언젠가 회수 된다. 

------------------------------------------------------------------------

생성자와 소멸자 그리고 this 키워드
    
        - 객체가 생성될 때 호출되는 생성자, 객체가 소멸할 때 호출되는 소멸자

    디폴트 생성자

        객체가 생성될 때 가장 먼저 호출되는 생성자, 개발자가 명시하지 않아도 컴파일 시점에 자동 생성된다.

        ex)

            ObjectEx obj1 = new ObjectEx();
                            디폴트 생성자 호출한다.

            public ObjectEx() {
                System.out.println("Default constructor")
            }

            정의해둔 디폴트 생성자가 없는 경우 컴파일러가 자동 생성된다. (객체 생성에 문제가 없도록 함.)

            public ObjectEx() {

            }

    사용자 정의 생성자

        디폴트 생성자 외에 특정 목적에 의해서 개발자가 만든 생성자로, 매개변수에 차이가 있다.

    소멸자

    this 키워드